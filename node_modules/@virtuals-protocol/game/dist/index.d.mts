import { Axios } from 'axios';

declare enum ExecutableGameFunctionStatus {
    Done = "done",
    Failed = "failed"
}
type ExecutableGameFunctionResponseJSON = ReturnType<ExecutableGameFunctionResponse["toJSON"]>;
declare class ExecutableGameFunctionResponse {
    status: ExecutableGameFunctionStatus;
    feedback: string;
    constructor(status: ExecutableGameFunctionStatus, feedback: string);
    toJSON(id: string): {
        action_id: string;
        action_status: ExecutableGameFunctionStatus;
        feedback_message: string;
    };
}
interface IGameFunction<T extends GameFunctionArg[]> {
    name: string;
    description: string;
    args: T;
    executable: (args: Partial<ExecutableArgs<T>>, logger: (msg: string) => void) => Promise<ExecutableGameFunctionResponse>;
    hint?: string;
}
interface GameFunctionArg {
    name: string;
    description: string;
    type?: string;
    optional?: boolean;
}
type GameFunctionBase = {
    name: string;
    description: string;
    args: GameFunctionArg[];
    executable: (args: Record<string, string>, logger: (msg: string) => void) => Promise<ExecutableGameFunctionResponse>;
    hint?: string;
    execute: (args: Record<string, {
        value: string;
    }>, logger: (msg: string) => void) => Promise<ExecutableGameFunctionResponse>;
    toJSON(): Object;
};
type ExecutableArgs<T extends GameFunctionArg[]> = {
    [K in T[number]["name"]]: string;
};
declare class GameFunction<T extends GameFunctionArg[]> implements IGameFunction<T> {
    name: string;
    description: string;
    args: T;
    executable: (args: Partial<ExecutableArgs<T>>, logger: (msg: string) => void) => Promise<ExecutableGameFunctionResponse>;
    hint?: string;
    constructor(options: IGameFunction<T>);
    toJSON(): {
        fn_name: string;
        fn_description: string;
        args: T;
        hint: string | undefined;
    };
    execute(args: {
        [key in GameFunctionArg["name"]]: {
            value: string;
        };
    }, logger: (msg: string) => void): Promise<ExecutableGameFunctionResponse>;
}

interface IGameWorker {
    id: string;
    name: string;
    description: string;
    functions: GameFunctionBase[];
    getEnvironment?: () => Promise<Record<string, any>>;
}
declare class GameWorker implements IGameWorker {
    id: string;
    name: string;
    description: string;
    functions: GameFunctionBase[];
    getEnvironment?: () => Promise<Record<string, any>>;
    private agentId;
    private logger;
    private gameClient;
    private gameActionResult;
    constructor(options: IGameWorker);
    setAgentId(agentId: string): void;
    setLogger(logger: (msg: string) => void): void;
    setGameClient(gameClient: IGameClient): void;
    step(submissionId: string, options?: {
        verbose: boolean;
    }): Promise<boolean>;
    runTask(task: string, options?: {
        verbose: boolean;
    }): Promise<void>;
}

interface Map {
    id: string;
}
interface GameAgent$1 {
    id: string;
    name: string;
    goal: string;
    description: string;
}
declare enum ActionType {
    CallFunction = "call_function",
    ContinueFunction = "continue_function",
    Wait = "wait",
    TryToTalk = "try_to_talk",
    Conversation = "conversation",
    GoTo = "go_to",
    Unknown = "unknown"
}
interface ActionArgs {
    location_id: string;
    task_id: string;
    fn_id: string;
    args: Record<string, any>;
    fn_name: string;
    thought: string;
}
interface GameAction {
    action_type: ActionType;
    action_args: ActionArgs;
    agent_state?: Record<string, any>;
}
interface IGameClient {
    client: Axios | null;
    createMap(workers: GameWorker[]): Promise<Map>;
    createAgent(name: string, goal: string, description: string): Promise<GameAgent$1>;
    getAction(agentId: string, mapId: string, worker: GameWorker, gameActionResult: ExecutableGameFunctionResponseJSON | null, environment: Record<string, any>, agentState: Record<string, any>): Promise<GameAction>;
    setTask(agentId: string, task: string): Promise<string>;
    getTaskAction(agentId: string, submissionId: string, worker: GameWorker, gameActionResult: ExecutableGameFunctionResponseJSON | null, environment: Record<string, any>): Promise<GameAction>;
}

interface IGameAgent {
    name: string;
    goal: string;
    description: string;
    workers: GameWorker[];
    getAgentState?: () => Promise<Record<string, any>>;
}
declare class GameAgent implements IGameAgent {
    name: string;
    goal: string;
    description: string;
    workers: GameWorker[];
    getAgentState?: () => Promise<Record<string, any>>;
    private workerId;
    private gameClient;
    private agentId;
    private mapId;
    private gameActionResult;
    log(msg: string): void;
    constructor(apiKey: string, options: IGameAgent);
    init(): Promise<void>;
    setLogger(logger: (agent: GameAgent, msg: string) => void): void;
    getWorkerById(workerId: string): GameWorker;
    step(options?: {
        verbose: boolean;
    }): Promise<ActionType.CallFunction | ActionType.ContinueFunction | ActionType.Wait | ActionType.GoTo | ActionType.Unknown>;
    run(heartbeatSeconds: number, options?: {
        verbose: boolean;
    }): Promise<void>;
}

export { ExecutableGameFunctionResponse, ExecutableGameFunctionStatus, GameAgent, GameFunction, GameWorker };
