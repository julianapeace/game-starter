"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const game_1 = require("@virtuals-protocol/game");
const postTweetFunction = new game_1.GameFunction({
    name: "post_tweet",
    description: "Post a tweet",
    args: [
        { name: "tweet", description: "The tweet content" },
        { name: "tweet_reasoning", description: "The reasoning behind the tweet" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            // TODO: Implement posting tweet
            logger(`Posting tweet: ${args.tweet}`);
            logger(`Reasoning: ${args.tweet_reasoning}`);
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, "Tweet posted");
        }
        catch (e) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to post tweet");
        }
    }),
});
const searchTweetsFunction = new game_1.GameFunction({
    name: "search_tweets",
    description: "Search tweets and return results",
    args: [
        { name: "query", description: "The query to search for" },
        { name: "reasoning", description: "The reasoning behind the search" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const query = args.query;
            //TODO: Implement searching tweets
            logger(`Searching tweets for query: ${query}`);
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, 
            // Return the search results as a string
            "Tweets searched here are the results: [{tweetId: 1, content: 'Hello World'}, {tweetId: 2, content: 'Goodbye World'}]");
        }
        catch (e) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to search tweets");
        }
    }),
});
const replyToTweetFunction = new game_1.GameFunction({
    name: "reply_to_tweet",
    description: "Reply to a tweet",
    args: [
        { name: "tweet_id", description: "The tweet id to reply to" },
        { name: "reply", description: "The reply content" },
    ],
    executable: (args, logger) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const tweetId = args.tweet_id;
            const reply = args.reply;
            //TODO: Implement replying to tweet
            logger(`Replying to tweet ${tweetId} with ${reply}`);
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Done, `Replied to tweet ${tweetId} with ${reply}`);
        }
        catch (e) {
            return new game_1.ExecutableGameFunctionResponse(game_1.ExecutableGameFunctionStatus.Failed, "Failed to reply to tweet");
        }
    }),
});
// Create a worker with the functions
const postTweetWorker = new game_1.GameWorker({
    id: "twitter_main_worker",
    name: "Twitter main worker",
    description: "Worker that posts tweets",
    functions: [searchTweetsFunction, replyToTweetFunction, postTweetFunction],
    // Optional: Get the environment
    getEnvironment: () => __awaiter(void 0, void 0, void 0, function* () {
        return {
            tweet_limit: 15,
        };
    }),
});
// Create an agent with the worker
const agent = new game_1.GameAgent("API_KEY", {
    name: "Twitter Bot",
    goal: "Search and reply to tweets",
    description: "A bot that searches for tweets and replies to them",
    workers: [postTweetWorker],
    // Optional: Get the agent state
    getAgentState: () => __awaiter(void 0, void 0, void 0, function* () {
        return {
            username: "twitter_bot",
            follower_count: 1000,
            tweet_count: 10,
        };
    }),
});
(() => __awaiter(void 0, void 0, void 0, function* () {
    // define custom logger
    agent.setLogger((agent, msg) => {
        console.log(`-----[${agent.name}]-----`);
        console.log(msg);
        console.log("\n");
    });
    // Initialize the agent
    yield agent.init();
    // Run the agent for with 60 seconds interval
    // this will stop when agent decides to wait
    yield agent.run(60, { verbose: true }); // verbose will give you more information about the agent's actions
    // if you need more control over the agent, you can use the step method
    // await agent.step();
}))();
